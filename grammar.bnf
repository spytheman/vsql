/* This file describes the SQL grammar from the BNF rules defined in the SQL */
/* 2016 standard. Unfortunatly, the standard is not open source and many of */
/* the rules below are only partially  */

<preparable statement> /* Stmt */ ::=
    <preparable SQL data statement>
  | <preparable SQL schema statement>
  | <preparable SQL transaction statement>

<SQL schema statement> /* Stmt */ ::=
    <SQL schema definition statement>
  | <SQL schema manipulation statement>

<SQL schema definition statement> /* Stmt */ ::=
    <schema definition>
  | <table definition>

<schema definition> /* Stmt */ ::=
    CREATE SCHEMA <schema name clause>   -> schema_definition

<schema name clause> /* Identifier */ ::=
    <schema name>

<schema name> /* Identifier */ ::=
    <unqualified schema name>

<unqualified schema name> /* Identifier */ ::=
    <identifier>

<SQL schema manipulation statement> /* Stmt */ ::=
    <drop schema statement>
  | <drop table statement>

<drop schema statement> /* Stmt */ ::=
    DROP SCHEMA <schema name> <drop behavior>   -> drop_schema_statement

<drop behavior> /* string */ ::=
    CASCADE
  | RESTRICT

<drop table statement> /* Stmt */ ::=
    DROP TABLE <table name>   -> drop_table_statement

<table name> /* Identifier */ ::=
    <local or schema qualified name>

<local or schema qualified name> /* Identifier */ ::=
    <qualified identifier>
  | <local or schema qualifier> <period>
    <qualified identifier>                 -> local_or_schema_qualified_name2

<local or schema qualifier> /* Identifier */ ::=
    <schema name>

<qualified identifier> /* Identifier */ ::=
    <identifier>

<identifier> /* Identifier */ ::=
    <actual identifier>

<actual identifier> /* Identifier */ ::=
    <regular identifier>

<regular identifier> /* Identifier */ ::=
    <identifier body>

<identifier body> /* Identifier */ ::=
    <identifier start>

<identifier start> /* Identifier */ ::=
    ^identifier

<table definition> /* CreateTableStmt */ ::=
    CREATE TABLE <table name> <table contents source> -> table_definition

<table contents source> /* []TableElement */ ::=
    <table element list>

<table element list> /* []TableElement */ ::=
    <left paren>
    <table elements>
    <right paren>      -> table_element_list

<table elements> /* []TableElement */ ::=
    <table element>                            -> table_elements1
  | <table elements> <comma> <table element>   -> table_elements2

<table element> /* TableElement */ ::=
    <column definition>
  | <table constraint definition>

<column definition> /* TableElement */ ::=
    <column name> <data type or domain name>   -> column_definition1
  | <column name> <data type or domain name>
    <column constraint definition>             -> column_definition2

<column name> /* Identifier */ ::=
    <identifier>

<data type or domain name> /* Type */ ::=
    <data type>

<data type> /* Type */ ::=
    <predefined type>

<predefined type> /* Type */ ::=
    <character string type>
  | <numeric type>
  | <boolean type>
  | <datetime type>

<character string type> /* Type */ ::=
    CHARACTER                                                         -> character
  | CHARACTER <left paren> <character length> <right paren>           -> character_n
  | CHAR                                                              -> character
  | CHAR <left paren> <character length> <right paren>                -> character_n
  | CHARACTER VARYING <left paren> <character length> <right paren>   -> varchar
  | CHAR VARYING <left paren> <character length> <right paren>        -> varchar
  | VARCHAR <left paren> <character length> <right paren>             -> varchar

<left paren> ::= "("

<right paren> ::= ")"

<character length> /* string */ ::=
    <length>

<length> /* string */ ::=
    <unsigned integer>

<unsigned integer> /* string */ ::=
    ^integer

<comma> ::= ","

<numeric type> /* Type */ ::=
    <exact numeric type>
  | <approximate numeric type>

<exact numeric type> /* Type */ ::=
    NUMERIC                                                          -> numeric1
  | NUMERIC <left paren> <precision> <right paren>                   -> numeric2
  | NUMERIC <left paren> <precision> <comma> <scale> <right paren>   -> numeric3
  | DECIMAL                                                          -> decimal1
  | DECIMAL <left paren> <precision> <right paren>                   -> decimal2
  | DECIMAL <left paren> <precision> <comma> <scale> <right paren>   -> decimal3
  | SMALLINT                                                         -> smallint
  | INTEGER                                                          -> integer
  | INT                                                              -> integer
  | BIGINT                                                           -> bigint

<scale> /* int */ ::=
    <unsigned integer>

<approximate numeric type> /* Type */ ::=
    FLOAT                                          -> float
  | FLOAT <left paren> <precision> <right paren>   -> float_n
  | REAL                                           -> real
  | DOUBLE PRECISION                               -> double_precision

<precision> /* string */ ::=
    <unsigned integer>

<boolean type> /* Type */ ::=
    BOOLEAN   -> boolean_type

<null specification> /* Expr */ ::=
    NULL   -> null

<implicitly typed value specification> /* Expr */ ::=
    <null specification>

<contextually typed value specification> /* Expr */ ::=
    <implicitly typed value specification>

<contextually typed row value constructor> /* []Expr */ ::=
    <common value expression>                        -> expr_to_list
  | <boolean value expression>                       -> expr_to_list
  | <contextually typed value specification>         -> expr_to_list
  | <left paren> <contextually typed value specification>
    <right paren>                                    -> expr_to_list
  | <left paren>
    <contextually typed row value constructor element> <comma>
    <contextually typed row value constructor element list>
    <right paren>                                    -> append_exprs2

<contextually typed row value constructor element> /* Expr */ ::=
    <value expression>
  | <contextually typed value specification>

<contextually typed row value constructor element list> /* []Expr */ ::=
    <contextually typed row value constructor element>        -> expr_to_list
  | <contextually typed row value constructor element list>
    <comma>
    <contextually typed row value constructor element>        -> append_exprs1

<column constraint> /* bool */ ::=
    NOT NULL   -> yes

<column constraint definition> /* bool */ ::=
    <column constraint>

<delete statement: searched> /* Stmt */ ::=
    DELETE FROM <target table>   -> delete_statement
  | DELETE FROM <target table>
    WHERE <search condition>     -> delete_statement_where

<target table> /* Identifier */ ::=
    <table name>

<preparable SQL data statement> /* Stmt */ ::=
    <delete statement: searched>
  | <insert statement>
  | <dynamic select statement>
  | <update statement: searched>

<preparable SQL schema statement> /* Stmt */ ::=
    <SQL schema statement>

<exact numeric literal> /* Value */ ::=
    <unsigned integer>                               -> exact_numeric_literal1
  | <unsigned integer> <period>                      -> exact_numeric_literal2
  | <unsigned integer> <period> <unsigned integer>   -> exact_numeric_literal3
  | <period> <unsigned integer>                      -> exact_numeric_literal4

<unsigned numeric literal> /* Value */ ::=
    <exact numeric literal>

<unsigned literal> /* Value */ ::=
    <unsigned numeric literal>
  | <general literal>

<unsigned value specification> /* Expr */ ::=
    <unsigned literal>              -> value_to_expr
  | <general value specification>

<nonparenthesized value expression primary> /* Expr */ ::=
    <unsigned value specification>
  | <column reference>               -> identifier_to_expr
  | <set function specification>
  | <routine invocation>

<value expression primary> /* Expr */ ::=
    <parenthesized value expression>
  | <nonparenthesized value expression primary>

<numeric primary> /* Expr */ ::=
    <value expression primary>
  | <numeric value function>

<factor> /* Expr */ ::=
    <numeric primary>
  | <sign> <numeric primary>   -> sign_expr

<sign> /* string */ ::=
    <plus sign>
  | <minus sign>

<plus sign> /* string */ ::=
  "+"

<minus sign> /* string */ ::=
  "-"

<term> /* Expr */ ::=
    <factor>
  | <term> <asterisk> <factor>   -> binary_expr
  | <term> <solidus> <factor>    -> binary_expr

<asterisk> /* string */ ::=
  "*"

<solidus> /* string */ ::=
  "/"

<numeric value expression> /* Expr */ ::=
    <term>
  | <numeric value expression> <plus sign> <term>    -> binary_expr
  | <numeric value expression> <minus sign> <term>   -> binary_expr

<common value expression> /* Expr */ ::=
    <numeric value expression>
  | <string value expression>
  | <datetime value expression>

<datetime value expression> /* Expr */ ::=
    <datetime term>

<datetime term> /* Expr */ ::=
    <datetime factor>

<datetime factor> /* Expr */ ::=
    <datetime primary>

<datetime primary> /* Expr */ ::=
    <value expression primary>
  | <datetime value function>

<datetime value function> /* Expr */ ::=
    <current date value function>
  | <current time value function>
  | <current timestamp value function>
  | <current local time value function>
  | <current local timestamp value function>

<current date value function> /* Expr */ ::=
    CURRENT_DATE   -> current_date

<current time value function> /* Expr */ ::=
    CURRENT_TIME                                               -> current_time1
  | CURRENT_TIME <left paren> <time precision> <right paren>   -> current_time2

<current timestamp value function> /* Expr */ ::=
    CURRENT_TIMESTAMP                                  -> current_timestamp1
  | CURRENT_TIMESTAMP
    <left paren> <timestamp precision> <right paren>   -> current_timestamp2

<current local time value function> /* Expr */ ::=
    LOCALTIME                                               -> localtime1
  | LOCALTIME <left paren> <time precision> <right paren>   -> localtime2

<current local timestamp value function> /* Expr */ ::=
    LOCALTIMESTAMP                                     -> localtimestamp1
  | LOCALTIMESTAMP
    <left paren> <timestamp precision> <right paren>   -> localtimestamp2

<value expression> /* Expr */ ::=
    <common value expression>
  | <boolean value expression>

<search condition> /* Expr */ ::=
    <boolean value expression>

<boolean value expression> /* Expr */ ::=
    <boolean term>
  | <boolean value expression> OR <boolean term>   -> or

<boolean term> /* Expr */ ::=
    <boolean factor>
  | <boolean term> AND <boolean factor>   -> and

<boolean factor> /* Expr */ ::=
    <boolean test>
  | NOT <boolean test>   -> not

<boolean test> /* Expr */ ::=
    <boolean primary>
  | <boolean primary> IS <truth value>       -> boolean_test1
  | <boolean primary> IS NOT <truth value>   -> boolean_test2

<boolean primary> /* Expr */ ::=
    <predicate>
  | <boolean predicand>

<predicate> /* Expr */ ::=
    <comparison predicate>
  | <between predicate>
  | <like predicate>
  | <similar predicate>
  | <null predicate>

<comparison predicate> /* Expr */ ::=
    <row value predicand> <comparison predicate part 2>   -> comparison

<row value predicand> /* Expr */ ::=
  <row value constructor predicand>

<row value constructor predicand> /* Expr */ ::=
    <common value expression>
  | <boolean predicand>

<comparison predicate part 2> /* ComparisonPredicatePart2 */ ::=
    <comp op> <row value predicand>   -> comparison_part

<comp op> /* string */ ::=
    <equals operator>
  | <not equals operator>
  | <less than operator>
  | <greater than operator>
  | <less than or equals operator>
  | <greater than or equals operator>

<equals operator> ::= "="

<not equals operator> ::= "<>"

<less than operator> ::= "<"

<greater than operator> ::= ">"

<less than or equals operator> ::= "<="

<greater than or equals operator> ::= ">="

<period> ::= "."

<column reference> /* Identifier */ ::=
    <basic identifier chain>

<basic identifier chain> /* Identifier */ ::=
    <identifier chain>

<identifier chain> /* Identifier */ ::=
    <identifier>
  | <identifier> <period> <identifier>   -> identifier_chain1

<insert statement> /* Stmt */ ::=
    INSERT INTO
    <insertion target>
    <insert columns and source>   -> insert_statement

<insertion target> /* Identifier */ ::=
    <table name>

<insert columns and source> /* InsertStmt */ ::=
  <from constructor>

<from constructor> /* InsertStmt */ ::=
    <left paren> <insert column list> <right paren>
    <contextually typed table value constructor>   -> from_constructor

<insert column list> /* []Identifier */ ::=
    <column name list>

<column name list> /* []Identifier */ ::=
    <column name>                              -> column_name_list1
  | <column name list> <comma> <column name>   -> column_name_list2

<contextually typed table value constructor> /* []Expr */ ::=
    VALUES <contextually typed row value expression list>   -> exprs

<contextually typed row value expression list> /* []Expr */ ::=
    <contextually typed row value expression>
  | <contextually typed row value expression list> <comma>
    <contextually typed row value expression>                -> merge_expr_lists

<contextually typed row value expression> /* []Expr */ ::=
  <contextually typed row value constructor>

<parenthesized value expression> /* Expr */ ::=
    <left paren> <value expression> <right paren>   -> expr

<character string literal> /* Value */ ::=
    ^string

<general literal> /* Value */ ::=
    <character string literal>
  | <datetime literal>
  | <boolean literal>

<datetime literal> /* Value */ ::=
    <date literal>
  | <time literal>
  | <timestamp literal>

<date literal> /* Value */ ::=
    DATE <date string>   -> date_literal

<date string> /* Value */ ::=
    ^string

<time literal> /* Value */ ::=
    TIME <time string>   -> time_literal

<time string> /* Value */ ::=
    ^string

<timestamp literal> /* Value */ ::=
    TIMESTAMP <timestamp string>   -> timestamp_literal

<timestamp string> /* Value */ ::=
    ^string

<boolean literal> /* Value */ ::=
    TRUE      -> true
  | FALSE     -> false
  | UNKNOWN   -> unknown

<update statement: searched> /* Stmt */ ::=
    UPDATE <target table>
    SET <set clause list>      -> update_statement
  | UPDATE <target table>
    SET <set clause list>
    WHERE <search condition>   -> update_statement_where

<set clause list> /* map[string]Expr */ ::=
    <set clause>
  | <set clause list> <comma> <set clause>   -> set_clause_append

<set clause> /* map[string]Expr */ ::=
  <set target> <equals operator> <update source>   -> set_clause

<set target> /* Identifier */ ::=
    <update target>

<update target> /* Identifier */ ::=
    <object column>

<object column> /* Identifier */ ::=
    <column name>

<update source> /* Expr */ ::=
    <value expression>
  | <contextually typed value specification>

<dynamic select statement> /* Stmt */ ::=
    <cursor specification>

<cursor specification> /* Stmt */ ::=
    <query expression>   -> cursor_specification

<query expression> /* QueryExpression */ ::=
    <query expression body>                     -> query_expression
  | <query expression body> <order by clause>   -> query_expression_order
  | <query expression body>
    <result offset clause>                      -> query_expression_offset
  | <query expression body> <order by clause>
    <result offset clause>                      -> query_expression_order_offset
  | <query expression body>
    <fetch first clause>                        -> query_expression_fetch
  | <query expression body> <order by clause>
    <fetch first clause>                        -> query_expression_order_fetch
  | <query expression body> <order by clause>
    <result offset clause>
    <fetch first clause>                        -> query_expression_order_offset_fetch
  | <query expression body>
    <result offset clause>
    <fetch first clause>                        -> query_expression_offset_fetch

<query expression body> /* SimpleTable */ ::=
    <query term>

<query term> /* SimpleTable */ ::=
    <query primary>

<query primary> /* SimpleTable */ ::=
    <simple table>

<simple table> /* SimpleTable */ ::=
    <query specification>
  | <table value constructor>

<query specification> /* SimpleTable */ ::=
    SELECT
    <select list>
    <table expression>   -> query_specification

<select list> /* SelectList */ ::=
    <asterisk>                               -> asterisk
  | <select sublist>
  | <select list> <comma> <select sublist>   -> select_list2

<select sublist> /* SelectList */ ::=
    <derived column>       -> select_sublist1
  | <qualified asterisk>   -> select_sublist2

<qualified asterisk> /* QualifiedAsteriskExpr */ ::=
    <asterisked identifier chain> <period> <asterisk>   -> qualified_asterisk

<asterisked identifier chain> /* Identifier */ ::=
    <asterisked identifier>

<asterisked identifier> /* Identifier */ ::=
    <identifier>

<derived column> /* DerivedColumn */ ::=
    <value expression>               -> derived_column
  | <value expression> <as clause>   -> derived_column_as

<table expression> /* TableExpression */ ::=
    <from clause>                                    -> table_expression
  | <from clause> <where clause>                     -> table_expression_where
  | <from clause> <group by clause>                  -> table_expression_group
  | <from clause> <where clause> <group by clause>   -> table_expression_where_group

<from clause> /* TableReference */ ::=
    FROM <table reference list>   -> from_clause

<table reference list> /* TableReference */ ::=
    <table reference>

<table reference> /* TableReference */ ::=
    <table factor>   -> table_factor
  | <joined table>   -> joined_table

<joined table> /* QualifiedJoin */ ::=
    <qualified join>

<qualified join> /* QualifiedJoin */ ::=
    <table reference>
    JOIN <table reference> <join specification>   -> qualified_join1
  | <table reference> <join type>
    JOIN <table reference> <join specification>   -> qualified_join2

<join specification> /* Expr */ ::=
    <join condition>

<join condition> /* Expr */ ::=
    ON <search condition>   -> expr

<table factor> /* TablePrimary */ ::=
    <table primary>

<table primary> /* TablePrimary */ ::=
    <table or query name>                          -> table_primary_identifier
  | <derived table>                                -> table_primary_derived1
  | <derived table> <correlation or recognition>   -> table_primary_derived2

<table or query name> /* Identifier */ ::=
    <table name>

<as clause> /* Identifier */ ::=
    AS <column name>   -> identifier
  | <column name>

<where clause> /* Expr */ ::=
    WHERE <search condition>   -> expr

<null predicate part 2> /* bool */ ::=
    IS NULL       -> yes
  | IS NOT NULL   -> no

<null predicate> /* Expr */ ::=
    <row value predicand> <null predicate part 2>   -> null_predicate

<absolute value expression> /* Expr */ ::=
    ABS <left paren> <numeric value expression> <right paren>   -> abs

<numeric value function> /* Expr */ ::=
    <position expression>
  | <length expression>
  | <absolute value expression>
  | <modulus expression>
  | <trigonometric function>
  | <common logarithm>
  | <natural logarithm>
  | <exponential function>
  | <power function>
  | <square root>
  | <floor function>
  | <ceiling function>

<modulus expression> /* Expr */ ::=
    MOD <left paren> <numeric value expression dividend> <comma> 
    <numeric value expression divisor> <right paren>               -> mod

<numeric value expression dividend> /* Expr */ ::=
    <numeric value expression>

<numeric value expression divisor> /* Expr */ ::=
    <numeric value expression>

<trigonometric function> /* Expr */ ::=
    <trigonometric function name>
    <left paren> <numeric value expression> 
    <right paren>                             -> trig_func

<trigonometric function name> /* string */ ::=
    SIN
  | COS
  | TAN
  | SINH
  | COSH
  | TANH
  | ASIN
  | ACOS
  | ATAN

<common logarithm> /* Expr */ ::=
    LOG10 <left paren> <numeric value expression> <right paren>   -> log10

<natural logarithm> /* Expr */ ::=
    LN <left paren> <numeric value expression> <right paren>   -> ln

<exponential function> /* Expr */ ::=
    EXP <left paren> <numeric value expression> <right paren>   -> exp

<power function> /* Expr */ ::=
    POWER <left paren> <numeric value expression base> <comma> 
    <numeric value expression exponent> <right paren>            -> power

<numeric value expression base> /* Expr */ ::=
    <numeric value expression>

<numeric value expression exponent> /* Expr */ ::=
    <numeric value expression>

<square root> /* Expr */ ::=
    SQRT <left paren> <numeric value expression> <right paren>   -> sqrt

<floor function> /* Expr */ ::=
    FLOOR <left paren> <numeric value expression> <right paren>   -> floor

<ceiling function> /* Expr */ ::=
    CEIL <left paren> <numeric value expression> <right paren>      -> ceiling
  | CEILING <left paren> <numeric value expression> <right paren>   -> ceiling

<concatenation> /* Expr */ ::=
    <character value expression>
    <concatenation operator>
    <character factor>             -> concatenation

<character value expression> /* Expr */ ::=
    <concatenation>
  | <character factor>

<concatenation operator> ::= "||"

<character factor> /* Expr */ ::=
    <character primary>

<character primary> /* Expr */ ::=
    <value expression primary>
  | <string value function>

<string value expression> /* Expr */ ::=
    <character value expression>

<boolean predicand> /* Expr */ ::=
    <parenthesized boolean value expression>
  | <nonparenthesized value expression primary>

<parenthesized boolean value expression> /* Expr */ ::=
    <left paren> <boolean value expression> <right paren>   -> expr

<result offset clause> /* Expr */ ::=
    OFFSET <offset row count> <row or rows>   -> expr

<offset row count> /* Expr */ ::=
    <simple value specification>

<simple value specification> /* Expr */ ::=
    <literal>
  | <host parameter name>

<literal> /* Expr */ ::=
    <signed numeric literal>
  | <general literal>          -> value_to_expr

<signed numeric literal> /* Expr */ ::=
    <unsigned numeric literal>          -> value_to_expr
  | <sign> <unsigned numeric literal>   -> sign_expr

<fetch first clause> /* Expr */ ::=
    FETCH FIRST
    <fetch first quantity>
    <row or rows>
    ONLY                     -> fetch_first_clause

<row or rows> ::=
    ROW
  | ROWS

<fetch first quantity> /* Expr */ ::=
    <fetch first row count>

<fetch first row count> /* Expr */ ::=
    <simple value specification>

<routine invocation> /* Expr */ ::=
    <routine name> <SQL argument list>   -> routine_invocation

<routine name> /* Identifier */ ::=
    <qualified identifier>

<SQL argument list> /* []Expr */ ::=
    <left paren> <right paren>                  -> empty_exprs
  | <left paren> <SQL argument> <right paren>   -> expr_to_list
  | <left paren> <SQL argument list> <comma>
    <SQL argument> <right paren>                -> append_exprs1

<SQL argument> /* Expr */ ::=
    <value expression>

<general value specification> /* Expr */ ::=
    <host parameter specification>

<host parameter specification> /* Expr */ ::=
    <host parameter name>

<host parameter name> /* Expr */ ::=
    <colon> <identifier>   -> host_parameter_name

<colon> ::=
  ":"

<unique specification> ::=
  PRIMARY KEY   -> ignore

<unique constraint definition> /* TableElement */ ::=
  <unique specification> <left paren>
  <unique column list> <right paren>    -> unique_constraint_definition

<unique column list> /* []Identifier */ ::=
  <column name list>

<table constraint> /* TableElement */ ::=
  <unique constraint definition>

<table constraint definition> /* TableElement */ ::=
  <table constraint>

<position expression> /* Expr */ ::=
    <character position expression>

<character position expression> /* Expr */ ::=
    POSITION <left paren> <character value expression 1> IN 
    <character value expression 2> <right paren>              -> position

<character value expression 1> /* Expr */ ::=
    <character value expression>

<character value expression 2> /* Expr */ ::=
    <character value expression>

<length expression> /* Expr */ ::=
    <char length expression>
  | <octet length expression>

<char length expression> /* Expr */ ::=
    CHAR_LENGTH
    <left paren> <character value expression> <right paren>   -> char_length
  | CHARACTER_LENGTH
    <left paren> <character value expression> <right paren>   -> char_length

<octet length expression> /* Expr */ ::=
    OCTET_LENGTH
    <left paren> <string value expression> <right paren>   -> octet_length

<start transaction statement> /* Stmt */ ::=
  START TRANSACTION   -> start_transaction

<commit statement> /* Stmt */ ::=
    COMMIT        -> commit
  | COMMIT WORK   -> commit

<rollback statement> /* Stmt */ ::=
    ROLLBACK        -> rollback
  | ROLLBACK WORK   -> rollback

<SQL transaction statement> /* Stmt */ ::=
    <start transaction statement>
  | <commit statement>
  | <rollback statement>

<preparable SQL transaction statement> /* Stmt */ ::=
  <SQL transaction statement>

<between predicate> /* Expr */ ::=
    <row value predicand> <between predicate part 2>   -> between

<between predicate part 2> /* BetweenExpr */ ::=
    <between predicate part 1>
    <row value predicand> AND <row value predicand>   -> between1
  | <between predicate part 1> <is symmetric>
    <row value predicand> AND <row value predicand>   -> between2

<between predicate part 1> /* bool */ ::=
    BETWEEN       -> yes
  | NOT BETWEEN   -> no

<is symmetric> /* bool */ ::=
    SYMMETRIC    -> yes
  | ASYMMETRIC   -> no

<table value constructor> /* SimpleTable */ ::=
    VALUES <row value expression list>   -> table_value_constructor

<row value expression list> /* []Expr */ ::=
    <table row value expression>           -> expr_to_list
  | <row value expression list>
    <comma> <table row value expression>   -> append_exprs1

<table row value expression> /* Expr */ ::=
    <row value constructor>

<row value constructor> /* Expr */ ::=
    <common value expression>
  | <boolean value expression>
  | <explicit row value constructor>

<derived table> /* TablePrimary */ ::=
    <table subquery>

<table subquery> /* TablePrimary */ ::=
    <subquery>

<subquery> /* TablePrimaryBody */ ::=
    <left paren> <query expression> <right paren>   -> subquery

<correlation or recognition> /* Correlation */ ::=
    <correlation name>                    -> correlation1
  | AS <correlation name>                 -> correlation1
  | <correlation name>
    <parenthesized derived column list>   -> correlation2
  | AS <correlation name>
    <parenthesized derived column list>   -> correlation2

<correlation name> /* Identifier */ ::=
    <identifier>

<parenthesized derived column list> /* []Identifier */ ::=
    <left paren> <derived column list>
    <right paren>                        -> parenthesized_derived_column_list

<derived column list> /* []Identifier */ ::=
    <column name list>

<explicit row value constructor> /* Expr */ ::=
    ROW <left paren> <row value constructor element list>
    <right paren>                                           -> row_constructor1
  | <row subquery>                                          -> row_constructor2

<row value constructor element list> /* []Expr */ ::=
    <row value constructor element>                -> expr_to_list
  | <row value constructor element list> <comma>
    <row value constructor element>                -> append_exprs1

<row value constructor element> /* Expr */ ::=
    <value expression>

<row subquery> /* QueryExpression */ ::=
    <subquery>

<character like predicate part 2> /* LikeExpr */ ::=
    LIKE <character pattern>       -> like
  | NOT LIKE <character pattern>   -> not_like

<character pattern> /* Expr */ ::=
    <character value expression>

<character like predicate> /* Expr */ ::=
    <row value predicand> <character like predicate part 2>   -> like_pred

<like predicate> /* Expr */ ::=
    <character like predicate>

<similar predicate part 2> /* SimilarExpr */ ::=
    SIMILAR TO <similar pattern>       -> similar
  | NOT SIMILAR TO <similar pattern>   -> not_similar

<similar pattern> /* Expr */ ::=
    <character value expression>

<similar predicate> /* Expr */ ::=
    <row value predicand> <similar predicate part 2>   -> similar_pred

<order by clause> /* []SortSpecification */ ::=
    ORDER BY <sort specification list>   -> order_by

<sort specification list> /* []SortSpecification */ ::=
    <sort specification>                                     -> sort_list1
  | <sort specification list> <comma> <sort specification>   -> sort_list2

<sort specification> /* SortSpecification */ ::=
    <sort key>                            -> sort1
  | <sort key> <ordering specification>   -> sort2

<sort key> /* Expr */ ::=
    <value expression>

<ordering specification> /* bool */ ::=
    ASC    -> yes
  | DESC   -> no

<character value function> /* Expr */ ::=
    <character substring function>
  | <fold>
  | <trim function>

<trim function> /* Expr */ ::=
  TRIM <left paren> <trim operands> <right paren>   -> trim

<trim operands> /* Expr */ ::=
    <trim source>                                              -> trim1
  | FROM <trim source>                                         -> trim1
  | <trim specification> FROM <trim source>                    -> trim2
  | <trim character> FROM <trim source>                        -> trim3
  | <trim specification> <trim character> FROM <trim source>   -> trim4

<trim source> /* Expr */ ::=
    <character value expression>

<trim specification> /* string */ ::=
    LEADING
  | TRAILING
  | BOTH

<trim character> /* Expr */ ::=
    <character value expression>

<fold> /* Expr */ ::=
    UPPER <left paren> <character value expression> <right paren>   -> upper
  | LOWER <left paren> <character value expression> <right paren>   -> lower

<string value function> /* Expr */ ::=
    <character value function>

<group by clause> /* []Expr */ ::=
    GROUP BY <grouping element list>   -> exprs

<grouping element list> /* []Expr */ ::=
    <grouping element>                                   -> expr_to_list
  | <grouping element list> <comma> <grouping element>   -> append_exprs1

<grouping element> /* Expr */ ::=
    <ordinary grouping set>

<ordinary grouping set> /* Expr */ ::=
    <grouping column reference>

<grouping column reference> /* Expr */ ::=
    <column reference>   -> identifier_to_expr

<aggregate function> /* Expr */ ::=
    COUNT <left paren> <asterisk> <right paren>   -> count_all
  | <general set function>

<set function specification> /* Expr */ ::=
    <aggregate function>

<general set function> /* Expr */ ::=
    <set function type> <left paren>
    <value expression> <right paren>   -> general_set_function

<set function type> /* string */ ::=
    <computational operation>

<computational operation> /* string */ ::=
    AVG
  | MAX
  | MIN
  | SUM
  | COUNT

<outer join type> /* string */ ::=
    LEFT
  | RIGHT

<join type> /* string */ ::=
    INNER
  | <outer join type>
  | <outer join type> OUTER   -> string

<datetime type> /* Type */ ::=
    DATE                                               -> date_type
  | TIME                                               -> time_type
  | TIME <left paren> <time precision> <right paren>   -> time_prec_type
  | TIME <with or without time zone>                   -> time_tz_type
  | TIME <left paren> <time precision> <right paren>
    <with or without time zone>                        -> time_prec_tz_type
  | TIMESTAMP                                          -> timestamp_type
  | TIMESTAMP
    <left paren> <timestamp precision> <right paren>   -> timestamp_prec_type
  | TIMESTAMP <with or without time zone>              -> timestamp_tz_type
  | TIMESTAMP
    <left paren> <timestamp precision> <right paren>
    <with or without time zone>                        -> timestamp_prec_tz_type

<time precision> /* string */ ::=
    <time fractional seconds precision>

<time fractional seconds precision> /* string */ ::=
    <unsigned integer>

<with or without time zone> /* bool */ ::=
    WITH TIME ZONE      -> yes
  | WITHOUT TIME ZONE   -> no

<timestamp precision> /* string */ ::=
    <time fractional seconds precision>

<time fractional seconds precision> /* string */ ::=
    <unsigned integer>

<character substring function> /* Expr */ ::=
    SUBSTRING <left paren> <character value expression>
    FROM <start position> <right paren>                   -> substring1
  | SUBSTRING <left paren> <character value expression>
    FROM <start position> 
    FOR <string length> <right paren>                     -> substring2
  | SUBSTRING <left paren> <character value expression>
    FROM <start position> 
    USING <char length units> <right paren>               -> substring3
  | SUBSTRING <left paren> <character value expression>
    FROM <start position> 
    FOR <string length>
    USING <char length units> <right paren>               -> substring4

<start position> /* Expr */ ::=
    <numeric value expression>

<string length> /* Expr */ ::=
    <numeric value expression>

<char length units> /* string */ ::=
    CHARACTERS
  | OCTETS

<truth value> /* Value */ ::=
    TRUE      -> true
  | FALSE     -> false
  | UNKNOWN   -> unknown
